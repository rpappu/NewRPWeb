<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.54">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Talks &amp; Presentations – Ravi Pappu</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-EBJBWFWYTE"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
 
  gtag('consent', 'default', {
    'ad_storage': 'denied',
    'analytics_storage': 'denied'
  });
gtag('config', 'G-EBJBWFWYTE', { 'anonymize_ip': true});
</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Ravi Pappu</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="./posts.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./talks.html" aria-current="page"> 
<span class="menu-text">Presentations</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Talks &amp; Presentations</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<style>
.filter-container {
  margin: 20px 0;
  padding: 15px;
  background-color: #f8f9fa;
  border-radius: 8px;
  border: 1px solid #e9ecef;
}

.filter-group {
  margin-bottom: 15px;
}

.filter-label {
  font-weight: 600;
  margin-bottom: 8px;
  display: block;
}

.filter-buttons {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.filter-btn {
  padding: 6px 12px;
  border: 1px solid #ddd;
  background: white;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  transition: all 0.2s;
}

.filter-btn:hover {
  background-color: #e9ecef;
}

.filter-btn.active {
  background-color: #007bff;
  color: white;
  border-color: #007bff;
}

.year-group {
  margin-bottom: 30px;
}

.year-header {
  font-size: 24px;
  font-weight: 700;
  color: #333;
  margin-bottom: 20px;
  padding-bottom: 8px;
  border-bottom: 2px solid #007bff;
}

.talk {
  margin-bottom: 25px;
  padding: 20px;
  background: white;
  border: 1px solid #e9ecef;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: all 0.2s;
}

.talk:hover {
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  transform: translateY(-2px);
}

.talk.selected {
  border-left: 4px solid #28a745;
  background: #f8fff9;
}

.talk-title {
  font-size: 18px;
  font-weight: 600;
  color: #333;
  margin-bottom: 8px;
}

.talk-authors {
  font-style: italic;
  color: #666;
  margin-bottom: 6px;
}

.talk-event {
  color: #555;
  margin-bottom: 6px;
  font-weight: 500;
}

.talk-location {
  color: #777;
  margin-bottom: 8px;
  font-size: 14px;
}

.talk-abstract {
  color: #555;
  margin-bottom: 10px;
  line-height: 1.5;
  font-size: 14px;
}

.talk-meta {
  display: flex;
  gap: 15px;
  margin-bottom: 10px;
  flex-wrap: wrap;
}

.talk-year {
  font-weight: 600;
  color: #007bff;
}

.talk-type {
  background: #6c757d;
  color: white;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
}

.talk-links {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
}

.talk-link {
  color: #007bff;
  text-decoration: none;
  font-weight: 500;
  font-size: 14px;
}

.talk-link:hover {
  text-decoration: underline;
}

.no-results {
  text-align: center;
  color: #666;
  font-style: italic;
  margin: 40px 0;
}

.stats {
  background: #e7f3ff;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 20px;
  border-left: 4px solid #007bff;
}
</style>
<!--
<div class="filter-container">
  <div class="filter-group">
    <label class="filter-label">Filter by Talk Type:</label>
    <div class="filter-buttons">
      <button class="filter-btn active" data-type="all">All Types</button>
      <button class="filter-btn" data-type="Keynote">Keynotes</button>
      <button class="filter-btn" data-type="Conference Talk">Conference Talks</button>
      <button class="filter-btn" data-type="Tech Talk">Tech Talks</button>
      <button class="filter-btn" data-type="Workshop">Workshops</button>
      <button class="filter-btn" data-type="Panel">Panels</button>
      <button class="filter-btn" data-type="Podcast">Podcasts</button>
    </div>
  </div>
</div>

<div class="stats" id="stats">
  Showing <span id="visible-count">13</span> of <span id="total-count">13</span> talks
</div>
-->
<div id="talks-container"></div>

<div class="no-results" id="no-results" style="display: none;">
  No talks found matching the selected filters.
</div>
<script>
const talks = [
  {
    title: "The Wright Approach to Ocean Data",
    authors: ["R. Pappu"],
    event: "Possibility Ocean 2025",
    location: "Newport, RI",
    year: 2025,
    type: "Keynote",
    abstract: "When it comes to scaling ocean data, what if we started with the price target instead of the technology? Dr. Ravi Pappu of Apeiron Labs proposes a new approach that shifts the focus from an engineering problem to an economic one. In this keynote, Dr. Pappu explores how cost influences accessibility, innovation, and scalability, and uncovers new possibilities for how we gather, use, and share ocean data.",
    pdf: "https://github.com/rpappu/pdf-publications/blob/master/Ravi%20-%20PO%20Keynote-2025.pdf",
    slides: "",
    video: "https://www.possibilityocean.com/media/keynote-ravi-pappu",
    selected: true
  },
  {
    title: "SpaceX for Oceans",
    authors: ["R. Pappu"],
    event: "S2G Summit",
    location: "Chicago, Il",
    year: 2024,
    type: "Fireside Chat",
    abstract: "Ravi Pappu, CEO of Apeiron Labs, addresses the environmental importance of obtaining upper ocean data, what excites him about ocean exploration, and his company’s goal to establish a global network of subsurface devices and create data-as-a-service platform for the oceans",
    pdf: "",
    slides: "",
    video: "https://www.youtube.com/watch?v=Wm2TfC6TBLc",
    selected: true
  },
  {
    title: "Physical Unclonable Functions: The First Fifty Years",
    authors: ["R. Pappu"],
    event: "ASHES 23 Keynote",
    location: "Copenhagen",
    year: 2023,
    type: "Keynote",
    abstract: "For over twenty years, Physical Unclonable Functions (PUFs) have spurred innovation in hardware security, giving rise to novel systems, protocols, attacks, and a deeper understanding of extracting entropy from the inherent disorder in physical structures. Despite this progress, a crucial gap remains. In this talk, I'll recount the (un)fortunate events that led me to discover PUFs and share key highlights of PUF research since. Looking back from a vantage point twenty years in the future, I'll explore some desired results required to bridge the gap and establish a theoretical framework for unclonability.",
    pdf: "https://github.com/rpappu/pdf-publications/blob/master/AshesKeyNoteFinal-Compressed.pdf",
    slides: "",
    video: "",
    selected: true
  },
  {
    title: "Technology Genomes and Innovation",
    authors: ["R. Pappu"],
    event: "Neo4j Graphtour",
    location: "",
    year: 2018,
    type: "Tech Talk",
    abstract: "I gave this talk on how InQTel uses graph databases to help us navigate the Mission Economy - the connection between startups, problems faced by the Intelligence Community, and the evolution of technology capabilities. The slides for this event are not public, but a case study (see link below) was published by Neo4j.",
    pdf: "",
    slides: "",
    video: "",
    whitepaper: "https://go.neo4j.com/rs/710-RRC-335/images/Neo4j-case-study-In-Q-Tel-EN-US.pdf?_ga=2.255500232.1715507714.1543692142-412101514.1543692142",
    selected: false
  },
  {
    title: "Deep Learning: Promise and Pitfalls",
    authors: ["R. Pappu"],
    event: "NVTC Tech Titans 2018",
    location: "Arlington, VA",
    year: 2018,
    type: "Panel",
    abstract: "I moderated a panel at the Northern Virginia Technology Council on the promise and panels of Deep Learning.",
    pdf: "",
    slides: "",
    video: "https://www.youtube.com/watch?time_continue=37&v=7bsPTZ4UeCI",
    selected: false
  },
  {
    title: "IoT Capabilities",
    authors: ["R. Pappu"],
    event: "MIT IoT Bootcamp",
    location: "Cambridge, MA",
    year: 2017,
    type: "Workshop",
    abstract: "Slides from a 90-minute talk I gave at the first MIT IoT Bootcamp.",
    pdf: "https://github.com/rpappu/talks/blob/master/PappuIoTCaps2017.pdf",
    slides: "https://gitpitch.com/rpappu/iotcaps#/",
    video: "",
    selected: false
  },
  {
    title: "Conway's Law and Innovation: a conjecture",
    authors: ["R. Pappu"],
    event: "Multiple locations",
    location: "",
    year: 2011,
    type: "Conference Talk",
    abstract: "I have give this talk several times over the past decade. It's primarily aimed at management to alert them to the hidden influence of organizational structures on innovation...or, why companies who get really good at one thing often have a very hard time doing something radically different.",
    pdf: "https://github.com/rpappu/talks/blob/master/ConwaysLawAndItsConsequences-Public.pdf",
    slides: "",
    video: "",
    selected: false
  },
  {
    title: "The Making of Camels",
    authors: ["R. Pappu"],
    event: "RFID Security Workshop",
    location: "Amherst, MA",
    year: 2011,
    type: "Workshop",
    abstract: "Sir Alec Issigonis, the designer of the Mini, is known to have said that \"a camel is a horse designed by a committee.\" In this talk, I will attempt to illuminate the process of how modern RFID standards are made through three examples. My goal is to convey the forces that make modern RFID standards as complicated as they are, and why it is usually very difficult for academic research to make its way into such standards in the short term.",
    pdf: "",
    slides: "",
    video: "https://vimeo.com/26960681",
    selected: false
  },
  {
    title: "The Physics of RFID",
    authors: ["R. Pappu", "M. Reynolds"],
    event: "RFID Security Workshop, 2011",
    location: "Amherst, MA",
    year: 2011,
    type: "Workshop",
    abstract: "Matt Reynolds and I gave a tutorial on the physics of RFID and UHF protocols at the RFID Security Workshop in June, 2011.",
    pdf: "",
    slides: "",
    video: "https://vimeo.com/27534223",
    selected: false
  },
  {
    title: "Passive RFID Innovation",
    authors: ["R. Pappu"],
    event: "MIT Auto-ID SIG",
    location: "Cambridge, MA",
    year: 2011,
    type: "Tech Talk",
    abstract: "This is a short talk on the innovation that I expected in passive RFID during 2011-2015",
    pdf: "",
    slides: "https://www.slideshare.net/ravipappu/ravi-pappu-autoidsigtalkmarch2011",
    video: "",
    selected: false
  },
  {
    title: "Reality Search Engines",
    authors: ["R. Pappu"],
    event: "Google Tech Talk",
    location: "",
    year: 2008,
    type: "Tech Talk",
    abstract: "A Google Tech Talk in Cambridge, MA. I spoke about how passive RFID is enabling Reality Search Engines - the ability to search physical space as easily as digital space.",
    pdf: "",
    slides: "https://www.slideshare.net/ravipappu/ravi-pappu-google-tech-talk-2008",
    video: "",
    selected: false
  },
  {
    title: "RFID Privacy Without Killing",
    authors: ["R. Pappu"],
    event: "RFID CUSP Workshop, Johns Hopkins University",
    location: "Baltimore, MD",
    year: 2008,
    type: "Workshop",
    abstract: "We explore the problem of secret-key distribution in unidirectional channels, those in which a sender transmits information blindly to a receiver. We consider two approaches: (1) Key sharing across space, i.e., via simultaneously emitted values that may follow different data paths and (2) Key sharing across time, i.e., in temporally staggered emissions. Our constructions are of general interest, treating, for instance, the basic problem of constructing highly compact secret shares. Our main motivating problem, however, is practical key management in RFID (Radio-Frequency IDentification) systems. We describe the application of our techniques to RFID-enabled supply chains and a prototype privacy-enhancing system.",
    pdf: "https://github.com/rpappu/talks/blob/master/Pappu-RFIDCUSP-Talk-2008.pdf",
    slides: "",
    video: "",
    selected: false
  },
  {
    title: "Physical One-Way Functions",
    authors: ["R. Pappu"],
    event: "Security Seminar, Cambridge University, UK",
    location: "Cambridge University, UK",
    year: 2002,
    type: "Conference Talk",
    abstract: "Modern cryptographic practice rests on the use of one-way functions, which are easy to evaluate but difficult to invert. Unfortunately, commonly used one-way functions are either based on unproven conjectures or have known vulnerabilities. We show that instead of relying on number theory, the mesoscopic physics of coherent transport through a disordered medium can be used to allocate and authenticate unique identifiers by physically reducing the medium's microstructure to a fixed-length string of binary digits. These physical one-way functions are inexpensive to fabricate, prohibitively difficult to duplicate, admit no compact mathematical representation, and are intrinsically tamper-resistant. We provide an authentication protocol based on the enormous address space that is a principal characteristic of physical one-way functions.",
    pdf: "",
    slides: "https://www.slideshare.net/ravipappu/ravi-pappu-security-seminar-cambridge-uk-sept2002",
    video: "https://vimeo.com/2351889",
    selected: false
  }
];

let currentFilter = 'all';

function renderTalks() {
  const container = document.getElementById('talks-container');
  const noResults = document.getElementById('no-results');
  
  // Filter talks
  const filteredTalks = currentFilter === 'all' 
    ? talks 
    : talks.filter(talk => talk.type === currentFilter);
  
  // Group by year
  const groupedByYear = filteredTalks.reduce((groups, talk) => {
    if (!groups[talk.year]) {
      groups[talk.year] = [];
    }
    groups[talk.year].push(talk);
    return groups;
  }, {});
  
  // Sort years descending
  const sortedYears = Object.keys(groupedByYear).sort((a, b) => b - a);
  
  if (filteredTalks.length === 0) {
    container.innerHTML = '';
    noResults.style.display = 'block';
  } else {
    noResults.style.display = 'none';
    
    container.innerHTML = sortedYears.map(year => {
      const yearTalks = groupedByYear[year];
      return `
        <div class="year-group">
          <h2 class="year-header">${year}</h2>
          ${yearTalks.map(talk => `
            <div class="talk ${talk.selected ? 'selected' : ''}">
              <div class="talk-title">${talk.title}</div>
              <div class="talk-authors">${talk.authors.join(', ')}</div>
              <div class="talk-event"><strong>${talk.event}</strong></div>
              ${talk.location ? `<div class="talk-location">📍 ${talk.location}</div>` : ''}
              <div class="talk-meta">
                <span class="talk-year">${talk.year}</span>
                <span class="talk-type">${talk.type}</span>
              </div>
              ${talk.abstract ? `<div class="talk-abstract">${talk.abstract}</div>` : ''}
              <div class="talk-links">
                ${talk.pdf ? `<a href="${talk.pdf}" class="talk-link" target="_blank">📄 PDF</a>` : ''}
                ${talk.slides ? `<a href="${talk.slides}" class="talk-link" target="_blank">📊 Slides</a>` : ''}
                ${talk.video ? `<a href="${talk.video}" class="talk-link" target="_blank">🎥 Video</a>` : ''}
                ${talk.podcast ? `<a href="${talk.podcast}" class="talk-link" target="_blank">🎙️ Podcast</a>` : ''}
                ${talk.whitepaper ? `<a href="${talk.whitepaper}" class="talk-link" target="_blank">📋 Whitepaper</a>` : ''}
              </div>
            </div>
          `).join('')}
        </div>
      `;
    }).join('');
  }
  
  // Update stats
  document.getElementById('visible-count').textContent = filteredTalks.length;
  document.getElementById('total-count').textContent = talks.length;
}

function setupFilters() {
  const filterButtons = document.querySelectorAll('.filter-btn');
  
  filterButtons.forEach(button => {
    button.addEventListener('click', () => {
      // Remove active class from all buttons
      filterButtons.forEach(btn => btn.classList.remove('active'));
      
      // Add active class to clicked button
      button.classList.add('active');
      
      // Update current filter
      currentFilter = button.dataset.type;
      
      // Re-render talks
      renderTalks();
    });
  });
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  setupFilters();
  renderTalks();
});
</script>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>